from pydantic import BaseModel, EmailStr, validator
from typing import List, Optional
from enum import Enum

class TemplateName(str, Enum):
    modern = "Modern"
    traditional = "Traditional"
    creative = "Creative"

class ResumeBase(BaseModel):
    name: str
    email: EmailStr
    template: TemplateName = TemplateName.modern

    @validator('name')
    def validate_name(cls, value):
        if not value:
            raise ValueError("Name must not be empty")
        return value

# Schema for creating a Resume, extending the base schema
class ResumeCreate(ResumeBase):
    pass

# Schema for reading a Resume, adding fields that are generated by the system
class ResumeRead(ResumeBase):
    id: int
    # Nested schemas for related objects can be included if needed
    # education_details: List[EducationDetailRead] = []
    # skills: List[SkillRead] = []
    # These would need corresponding Pydantic schemas defined similarly

# Additional schemas for updating if needed
class ResumeUpdate(ResumeBase):
    name: Optional[str] = None
    email: Optional[EmailStr] = None
    template: Optional[TemplateName] = None